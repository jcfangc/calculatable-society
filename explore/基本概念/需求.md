
- [需求](#需求)
    - [1. 需求的表示](#1-需求的表示)
        - [1.1. 群体利益总和](#11-群体利益总和)
        - [1.2. 个体需求定义](#12-个体需求定义)
        - [1.3. 多群体需求计算](#13-多群体需求计算)
        - [1.4. 三元组表示](#13-三元组表示)
        - [1.5. 扩展矩阵表示](#14-扩展矩阵表示)
    - [2. 需求的列向量表示](#2-需求的列向量表示)
        - [2.1. 个体需求列向量](#21-个体需求列向量)
        - [2.2. 资源需求简写](#22-资源需求简写)

# 需求

## 1. 需求的表示

### 1.1. 群体利益总和

群体中某项利益的总和不仅取决于群体所有成员在该项利益上的值的累加，还需要考虑每个成员的声望程度。个体的[声望系数](\基本概念\群体.md#223-声望程度)可以作为其贡献权重的指标，声望程度越高（即声望系数越大），其贡献权重越大。我们可以通过调整累加的权重来实现这一点：

\[I(G)[x] = \sum_{i=0}^{|G|} w(P_i) \cdot I(P_i)[x],\ P_i \in G \]

其中：

- \(I(G)[x]\) 表示群体中关于利益 \(x\) 的加权总和。
- \(P_i\) 代表群体中的一个个体。
- \(|G|\) 代表群体的成员总数。
- \(w(P_i)\) 是个体 \(P_i\) 的贡献权重，与其声望系数 \(RP(P_i)\) 相关，可通过某种函数来确定。

我们可以使用一种规范化函数来转换每个个体的声望系数，一个常见的方法是使用Softmax函数，这是一种在机器学习中广泛使用的规范化函数。具体来说，对于群体中的每个个体\(P_i\)，其贡献权重\(w(P_i)\)可以通过以下方式计算：

\[w(P_i) = \frac{e^{RP(P_i)}}{\sum_{j=0}^{|G|} e^{RP(P_j)}},\ P_i, P_j \in G \]

其中：

- \(RP(P_i)\)是个体\(P_i\)的声望系数。
- 分子部分是个体\(P_i\)声望系数的指数。
- 分母部分是群体中所有成员声望系数的指数负值之和，确保了所有\(w(P_i)\)的总和为1

### 1.2. 个体需求定义
个体在某项利益上的需求是根据个体利益与群体利益总和的关系来定义的。具体地说，个体 \(P\) 在利益 \(x\) 上的需求 \(D(P)[x]\) 可以定义为：
\[D(P)[x] = \frac{{I(G)[x]}}{I(P)[x] \cdot |G|},\ P \in G \]
这里，\(D(P)[x]\) 表示个体 \(P\) 关于利益 \(x\) 的需求。这个公式反映了群体中该项利益的平均分配与个体当前拥有的该项利益之间的比值。

```python
class Demand:
    def __init__(self, individual, groups):
        """
        :param individual: 需求计算所基于的个体实例
        :param groups: 包含该个体的群体集合
        """
        self.individual = individual
        self.groups = groups
        self.demands = self.calculate_demands()

    def calculate_demands(self):
        """
        根据个体所属的群体集合计算各种利益的需求。
        :return: 一个字典，格式为{利益名: 需求水平, ...}
        """
        pass
```

### 1.3. 多群体需求计算

规定当个体属于不仅仅一个群体时，假设个体 \( P \) 参与了 \( n \) 个群体 \( G_1, G_2, \ldots, G_n \)，每个群体 \( G_i \) 有 \( |G_i| \) 个成员，群体利益为 \( I(G_i) \)，则个体 \( P \) 视角下的综合物质水平 \( I(M) \) 可以通过以下方式计算：
\[ I(M) = \frac{\sum_{i=1}^{n} |G_i| \cdot I(G_i)}{n} \]

在这种情况下，个体 \( P \) 在利益 \( x \) 上的需求 \( D(P)[x] \) 可以定义为：

\[ D(P)[x] = \frac{{I(M)[x]}}{I(P)[x] \cdot |M|},\ P \in  G_1, G_2, \ldots, G_n \]

其中 \( |M| \) 定义为：

\[ |M| = \frac{\sum_{i=1}^{n} |G_i|}{n} \]

综上，个体在多个群体中的需求可以通过下式计算：

\[ D(P)[x] = \frac{{\sum_{i=1}^{n} |G_i| \cdot I(G_i)[x]}}{I(P)[x] \cdot \sum_{i=1}^{n} |G_i|} \]

### 1.4. 三元组表示

个体 \(P\) 现在可以由一系列三元组构成，每个三元组代表一个特定利益、其对应的偏好级别，以及该利益的需求水平。这种表示方法不仅显示了个体在不同领域的利益及其重视程度，还包括了基于所属群体的需求水平，为分析和研究提供了更全面的基础。示例如下：

\[P = [(I_{物质财富}, H_{物质财富}, D_{物质财富}),\ (I_{权力}, H_{权力}, D_{权力}),\ (I_{知识}, H_{知识}, D_{知识}),\ ...] \]

```python
class Individual:
    def __init__(self, interests=None, preferences=None, groups=None):
        """
        :param interests: 个体拥有的利益，格式为{利益名: 数量, ...}
        :param preferences: 个体的偏好，格式为{利益名: 偏好级别, ...}
        :param groups: 个体所属的群体及其在群体中的声望，格式为{群体实例: 声望, ...}
        """
        self.interests = interests if interests else {}
        self.preferences = preferences if preferences else {}
        self.groups = groups if groups else {}
        self.demands = None  # 需求将通过 Demand 类计算得到

    def update_demands(self):
        """
        使用 Demand 类更新个体的需求水平。
        """
        self.demands = Demand(self, self.groups.keys()).demands

    def add_group(self, group, prestige):
        """
        将个体添加到一个新群体中，并设置其在该群体中的声望。
        :param group: 群体的实例
        :param prestige: 个体在该群体中的声望
        """
        self.groups[group] = prestige

    def update_prestige(self, group, new_prestige):
        """
        更新个体在特定群体中的声望。
        :param group: 群体的实例
        :param new_prestige: 个体的新声望值
        """
        if group in self.groups:
            self.groups[group] = new_prestige
```

### 1.5. 扩展矩阵表示

个体的矩阵表示法可以扩展包含三个维度：利益、偏好级别和需求水平。每一行代表一个特定的利益，每一行的三个元素分别对应于该利益的量、偏好级别以及需求水平。这种表示法在处理复杂数据或进行数学运算时特别方便，使得我们可以高效地处理和分析个体的多维属性。示例如下：

\[ P = \begin{bmatrix} 
I_{物质财富} & H_{物质财富} & D_{物质财富} \\
I_{权力} & H_{权力} & D_{权力} \\
I_{知识} & H_{知识} & D_{知识} \\
... & ... & ... \\
\end{bmatrix} \]

## 2. 需求的列向量表示

### 2.1. 个体需求列向量
个体的需求可以表示为一个列向量，其中包含了个体对所有利益的需求值：
\[ D(P) = [ D[x],\ D[y],\ D[z],\ ... ] \]
这个向量提供了一个全面的视角，展示了个体在各个利益方面的需求程度。

### 2.2. 资源需求简写
为了简化表示，个体 \(P\) 关于资源 \(x\) 的需求 \(D_x\) 可以简写为 \(D(P)[x]\)。在上下文明确的情况下，进一步简化为 \(D[x]\)。